# day 18

## Section

```elixir
defmodule SnailNumber do
  def print_list(x), do: inspect(x, charlists: :as_lists)
  def add({_, _} = a, {_, _} = b), do: reduce_min({a, b})

  def from_list([a, b]), do: {from_list(a), from_list(b)}
  def from_list(n) when is_number(n), do: n

  def reduce_min(num) do
    case reduce(num) do
      nil ->
        num

      n ->
        if n == num, do: n, else: reduce_min(n)
    end
  end

  def reduce({_, _} = n) do
    case explode(n, 0) do
      nil ->
        case split(n) do
          nil -> n
          n -> n
        end

      {_, exploded, _} ->
        exploded
    end
  end

  def explode(n, _) when is_number(n), do: nil
  def explode({l, r}, n) when is_number(l) and is_number(r) and n > 3, do: {l, 0, r}

  def explode({l, r}, n) do
    case explode(l, n + 1) do
      nil ->
        case explode(r, n + 1) do
          nil ->
            nil

          {x_l, x, x_r} ->
            l = hit(l, x_l, :right)
            {nil, {l, x}, x_r}
        end

      {x_l, x, x_r} ->
        r = hit(r, x_r, :left)
        {x_l, {x, r}, nil}
    end
  end

  def magnitude(n) when is_number(n), do: n

  def magnitude({l, r}) do
    3 * magnitude(l) + 2 * magnitude(r)
  end

  defp hit(x, nil, _), do: x
  defp hit(num, n, _) when is_number(num), do: num + n
  defp hit({l, r}, n, :left) when is_number(l) and is_number(n), do: {l + n, r}
  defp hit({l, r}, n, :right) when is_number(r) and is_number(n), do: {l, r + n}
  defp hit({l, r}, n, :left), do: {hit(l, n, :left), r}
  defp hit({l, r}, n, :right), do: {l, hit(r, n, :right)}

  def split(n) when is_number(n) and n >= 10 do
    half = n / 2.0
    {half |> floor(), half |> ceil()}
  end

  def split(n) when is_number(n), do: nil

  def split({l, r}) do
    case split(l) do
      nil ->
        case split(r) do
          nil -> nil
          r -> {l, r}
        end

      l ->
        {l, r}
    end
  end
end
```

```elixir
import SnailNumber

[
  {[[[[[9, 8], 1], 2], 3], 4], [[[[0, 9], 2], 3], 4]},
  {[7, [6, [5, [4, [3, 2]]]]], [7, [6, [5, [7, 0]]]]},
  {[[6, [5, [4, [3, 2]]]], 1], [[6, [5, [7, 0]]], 3]},
  {[[3, [2, [1, [7, 3]]]], [6, [5, [4, [3, 2]]]]], [[3, [2, [8, 0]]], [9, [5, [4, [3, 2]]]]]},
  {[[3, [2, [8, 0]]], [9, [5, [4, [3, 2]]]]], [[3, [2, [8, 0]]], [9, [5, [7, 0]]]]}
]
|> Enum.map(fn {input, expected} ->
  input = input |> SnailNumber.from_list()
  res = SnailNumber.reduce(input)
  expected = SnailNumber.from_list(expected)
  IO.inspect("Output: #{inspect(res)}, expected #{inspect(expected)}")
  res == expected
end)
|> IO.inspect()
```

```elixir
import SnailNumber

defmodule Solution do
  def solve_puzzle(inputs, args \\ []) do
    inputs
    |> Enum.reduce(fn n, acc ->
      reduced = acc |> add(n)

      if Keyword.get(args, :print_intermediate, false),
        do: IO.inspect(reduced, label: "after #{inspect(n)}")

      reduced
    end)
    # |> IO.inspect(label: :before_reduce_min, charlists: :as_lists)
    |> SnailNumber.reduce_min()
    |> IO.inspect(label: :final_solution, charlists: :as_lists)
    |> SnailNumber.magnitude()
  end

  def parse_str(str) do
    str
    |> String.split("\n", trim: true)
    |> Enum.map(fn line ->
      {code, _} = Code.eval_string(line)
      code
    end)
    |> Enum.map(&SnailNumber.from_list/1)
  end

  def solve_puzzle_from_str(str, args \\ []), do: parse_str(str) |> solve_puzzle(args)
end

"""
[1,1]
[2,2]
[3,3]
[4,4]
"""
|> Solution.solve_puzzle_from_str(print_intermediate: true)

"""
[1,1]
[2,2]
[3,3]
[4,4]
[5,5]
"""
|> Solution.solve_puzzle_from_str(print_intermediate: true)

# """
# [1,1]
# [2,2]
# [3,3]
# [4,4]
# [5,5]
# [6,6]
# """
# |> Solution.solve_puzzle_from_str()
```

```elixir
# difficult

"""
[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]
[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]
[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]
[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]
[7,[5,[[3,8],[1,4]]]]
[[2,[2,2]],[8,[8,1]]]
[2,9]
[1,[[[9,3],9],[[9,0],[0,7]]]]
[[[5,[7,4]],7],1]
[[[[4,2],2],6],[8,7]]
"""
|> Solution.solve_puzzle_from_str(print_intermediate: true)
```

```elixir
# Debug example

a =
  [[[[4, 0], [5, 4]], [[7, 7], [6, 0]]], [[8, [7, 7]], [[7, 9], [5, 0]]]]
  |> SnailNumber.from_list()

b = [[2, [[0, 8], [3, 4]]], [[[6, 7], 1], [7, [1, 6]]]] |> SnailNumber.from_list()

SnailNumber.add(a, b) |> IO.inspect()

a = [[[[4, 3], 4], 4], [7, [[8, 4], 9]]] |> SnailNumber.from_list()
b = [1, 1] |> SnailNumber.from_list()
SnailNumber.add(a, b)
```

```elixir
"""
[[[0,[5,8]],[[1,7],[9,6]]],[[4,[1,2]],[[1,4],2]]]
[[[5,[2,8]],4],[5,[[9,9],0]]]
[6,[[[6,2],[5,6]],[[7,6],[4,7]]]]
[[[6,[0,7]],[0,9]],[4,[9,[9,0]]]]
[[[7,[6,4]],[3,[1,3]]],[[[5,5],1],9]]
[[6,[[7,3],[3,2]]],[[[3,8],[5,7]],4]]
[[[[5,4],[7,7]],8],[[8,3],8]]
[[9,3],[[9,9],[6,[4,9]]]]
[[2,[[7,7],7]],[[5,8],[[9,3],[0,2]]]]
[[[[5,2],5],[8,[3,7]]],[[5,[7,5]],[4,4]]]
"""
|> Solution.solve_puzzle_from_str()
```

```elixir
input_str = """
[[[7,[9,4]],[5,8]],7]
[[[[9,3],[9,0]],[[1,9],2]],4]
[2,[[[0,6],3],[7,6]]]
[4,[[[8,9],[4,2]],[[6,8],[2,7]]]]
[[6,[6,[6,8]]],[[[8,7],8],8]]
[[5,[[2,7],3]],[[[4,6],9],9]]
[[8,1],[9,7]]
[[[[9,3],[8,1]],[[6,6],[7,4]]],[[9,[9,8]],[6,3]]]
[[[6,0],[1,[1,6]]],[2,[[9,4],7]]]
[[[9,7],3],[[[8,4],[4,1]],[7,3]]]
[[[3,7],[[0,0],[3,1]]],[6,[[2,4],6]]]
[[[[3,0],3],[[9,2],[8,3]]],[[[5,3],[5,1]],[6,[4,6]]]]
[[7,[[7,6],[4,5]]],[[5,[0,0]],[[9,7],3]]]
[[[[0,0],8],[7,[6,0]]],[[[0,8],[7,5]],[[2,2],4]]]
[[[[5,6],[7,9]],1],[[[0,2],[7,9]],[[6,2],6]]]
[7,[0,5]]
[[2,[7,8]],[[[3,0],0],[0,8]]]
[[[[9,2],[4,8]],[1,[8,3]]],[[6,1],[[1,5],[7,3]]]]
[[[[7,1],6],[3,5]],[[8,[3,8]],[7,3]]]
[[[[1,7],8],0],[2,[[4,1],9]]]
[[[[9,2],0],0],[[1,[9,5]],3]]
[[1,[3,5]],7]
[[[[7,5],[4,1]],[[6,9],1]],[[0,8],[1,[4,2]]]]
[[6,[0,[5,4]]],[[4,[6,1]],3]]
[[[[5,8],4],[0,[1,5]]],[[[0,1],9],[[2,1],6]]]
[[[[9,5],3],[[1,6],6]],[9,[[1,4],[6,1]]]]
[[8,[[7,8],[6,1]]],[1,8]]
[[3,[[6,1],[2,7]]],[0,[3,[1,7]]]]
[[[[3,3],0],[[6,5],8]],[[[8,3],3],[5,[3,9]]]]
[[[1,6],9],[[9,4],1]]
[[[[5,3],[4,3]],[3,5]],[[4,[9,8]],[2,[8,5]]]]
[[[[7,3],6],7],[[[1,4],9],[3,[7,0]]]]
[[0,5],[[[4,3],7],[8,[0,3]]]]
[6,[[[9,4],2],[[8,4],[5,7]]]]
[[9,[2,[1,7]]],[4,[[7,2],3]]]
[9,[5,[[9,7],[0,5]]]]
[[[[1,6],1],[[2,3],[3,3]]],[[5,[8,6]],[[1,3],[8,9]]]]
[[3,0],[[4,1],[6,[5,7]]]]
[[[[3,3],[9,0]],[1,[0,0]]],[0,[[6,6],[1,1]]]]
[[[4,6],[[9,2],[0,5]]],0]
[9,[[5,5],[8,[4,1]]]]
[[[[9,2],[9,9]],[[8,7],3]],0]
[[2,5],[4,8]]
[[[[9,1],8],[1,2]],[7,[[7,2],5]]]
[2,7]
[[[[0,3],0],0],[[1,8],[[5,3],1]]]
[[[9,8],5],[[0,2],[4,[2,4]]]]
[[3,[9,[9,4]]],[3,[[3,0],7]]]
[[6,[5,1]],[4,7]]
[[5,[8,[4,1]]],[8,[[1,8],[1,7]]]]
[2,[[7,5],[[9,1],6]]]
[0,[4,[2,2]]]
[7,[[[9,5],[7,4]],[[5,0],[5,0]]]]
[8,[[[5,3],3],[5,[2,0]]]]
[[[[3,7],7],[[6,0],3]],[[[5,4],8],[[9,3],[2,9]]]]
[[[[8,1],3],[[8,4],[3,0]]],[2,6]]
[7,[9,7]]
[[[[4,9],9],0],[[[3,8],[6,9]],0]]
[[[[6,1],0],[[5,2],9]],4]
[[[4,1],[[8,5],8]],[[7,[9,4]],[[7,8],[0,9]]]]
[[0,2],5]
[[[5,[7,5]],[6,[7,3]]],[[[7,2],[7,5]],[[3,1],6]]]
[[[[5,1],[9,1]],[[3,2],[6,7]]],[8,[[3,5],8]]]
[[[4,[3,9]],[5,1]],[5,[[2,4],[9,0]]]]
[5,[[[8,5],5],1]]
[[[7,7],[[8,7],7]],[[9,2],[[3,5],[8,0]]]]
[[[[2,0],0],[[8,5],7]],[[[3,4],[8,1]],1]]
[[6,[[0,7],[1,9]]],[[[5,0],5],[7,[1,5]]]]
[[[0,[6,9]],[6,[9,4]]],[3,1]]
[[8,[2,9]],[5,[6,9]]]
[[[[9,4],[7,8]],8],[[[0,3],[8,8]],[[1,7],[8,2]]]]
[[[[9,5],[0,6]],[6,[3,5]]],5]
[[[[3,0],[4,9]],[5,4]],[5,[[1,2],[0,3]]]]
[[[[9,3],8],8],[2,9]]
[5,[[[8,4],[8,0]],[[9,2],[7,6]]]]
[[[[4,8],2],[4,0]],[[1,[2,1]],[0,[0,7]]]]
[3,[[[8,5],[8,6]],2]]
[[[3,[1,2]],9],[7,[2,[0,6]]]]
[[[[8,3],1],9],6]
[[2,[6,8]],[[6,9],[1,[4,9]]]]
[[[[5,9],3],[9,6]],[[[9,9],6],6]]
[[[[1,6],1],[2,[8,7]]],[4,[[7,6],3]]]
[[3,[8,[8,6]]],[[[2,0],3],6]]
[[[1,[6,5]],6],[7,[3,6]]]
[[2,[[8,3],3]],[[0,[3,4]],[5,[2,9]]]]
[[[9,4],[4,[0,1]]],[4,[3,5]]]
[[[5,[7,3]],[[7,5],[8,9]]],5]
[[[1,4],[4,5]],[[[4,8],4],0]]
[[[[9,2],2],[3,0]],[[[4,6],3],[0,7]]]
[[[[2,2],[0,4]],6],3]
[[[4,[6,2]],[3,[3,4]]],[[[1,1],0],[0,9]]]
[[[[8,2],[5,4]],[[4,4],8]],[4,[5,[6,4]]]]
[[[7,[2,4]],[6,[2,6]]],[[7,6],8]]
[[[[2,6],3],[6,[2,8]]],2]
[[[2,[2,9]],[4,[9,0]]],[[8,0],[[4,1],4]]]
[2,[3,[1,8]]]
[[[5,9],[[3,4],[1,9]]],[[6,[9,2]],6]]
[[[[1,5],[2,8]],[[4,1],3]],[[1,[6,3]],[[9,7],8]]]
[[[[7,8],9],4],2]
[[[0,[6,8]],6],5]
"""

input_str
|> Solution.solve_puzzle_from_str()
```

## Part 2

```elixir
nums = input_str |> Solution.parse_str()

pairs =
  for a <- nums,
      b <- nums,
      a != b do
    {a, b}
  end

pairs
|> Enum.map(fn {a, b} -> SnailNumber.add(a, b) |> SnailNumber.magnitude() end)
|> Enum.max()
```
